# What is SPA ?
<!-- - SPA stands for  Single Page Application . It's a type of web application or website that interacts with the user by dynamically rewriting the current web page rather than loading entire new pages from the server.
- In other words, a single HTML page is loaded initially, and then the content is updated dynamically as the user interacts with the application, typically through JavaScript. -->

SPA stands for  Single Page Application. Where a single HTML page is loaded initially, and then the content is updated dynamically as the user interacts with the application, typically through JavaScript.

# What is the difference between Client Side Routing and Server Side Routing ?
- Client-side routing and server-side routing are two different approaches to handling routing and navigation in web applications.
-  client-side routing is suitable for building SPAs and offers faster, more interactive user experiences but can pose SEO challenges. Server-side routing is more SEO-friendly and is used for traditional websites with separate HTML pages, but it can be slower in terms of page transitions. The choice between these two routing approaches depends on the specific requirements and goals of a web application or website. In some cases, a hybrid approach that combines both client-side and server-side routing techniques may be used to achieve the best of both worlds.

# Client-Side Routing 
<!-- - Handling on the Client : In client-side routing, routing and navigation are managed on the client side, typically within the web browser. JavaScript frameworks and libraries, such as React Router (for React applications) or Vue Router (for Vue.js applications), are commonly used to implement clientside routing.
- Faster Transitions : Client-side routing allows for faster page transitions since it doesn't require the server to send a new HTML page for each route change. Instead, it updates the DOM and URL dynamically without full page reloads.
- Single-Page Application (SPA) :  SPAs can face challenges with search engine optimization (SEO) because search engine crawlers may not fully index the content that relies heavily on client-side rendering. Special techniques like server-side rendering (SSR) or
pre-rendering can be used to address this issue.
- Route Management : Routing configuration is typically defined in code and managed on the client side, allowing for dynamic and flexible route handling. -->

- In client-side routing, routing and navigation are managed on the client side. 
- It's often assosiated with SPA, where the initial html page is loaded and subsequent page changes are madde by updation the content using javascript.
- It allows for faster page transitions since it doesn't require the server to send a new HTML page for each route change.
- It may face  challenges with search engine optimization (SEO) because search engine crawlers may not fully index the content that relies heavily on client-side rendering.

# Server-Side Routing
<!-- - Handling on the Server : Server-side routing manages routing and navigation on the server. When a user requests a different URL, the server generates and sends a new HTML page for that route.
- Slower Transitions : Server-side routing tends to be slower in terms of page transitions compared to client-side routing, as it involves full page reloads.
- Traditional Websites : Server-side routing is commonly used for traditional multipage websites where each page is a separate HTML document generated by the server
- SEO-Friendly : Server-side routing is inherently more SEO-friendly, as each page is
a separate HTML document that can be easily crawled and indexed by search engines.
- Route Configuration : - Routing configuration in server-side routing is typically managed on the server, and URLs directly correspond to individual HTML files or routes. -->

- In Server-side routing, routing and navigation are managed on the server. 
- When a user requests a different url, the server generates and sends a new html page for that route.
- It requires full page reload, making it slower compare to client-side rendering.
- It is SEO friendly, as each page is a seperate HTML document that can easily be crawled and indexed by search engine.

# React router
- React Router enables "client side routing".

# react-router-dom
- react-router-dom is a library specifically designed for handling routing in React applications. 
<!-- - It provides the tools and components needed to navigate between different views or pages within a React application, allowing for a smooth, single-page application (SPA) experience. -->

# createBrowserRouter
- This is the recommended router for all React Router web projects. It uses the DOM History API to update the URL and manage the history stack.
- It is a function used to create a router instance 

const appRouter=createBrowserRouter(
    [
        {
            path:'/',
            element:<Home/>,
        }
    ]
)
root.render(<RouterProvider router={appRoutes}>)

# RouterProvider
RouterProvider is a component that makes the router available to your entire application.

const appRouter=createBrowserRouter(
    [
        {
            path:'/',
            element:<Home/>,
        }
    ]
)
root.render(<RouterProvider router={appRoutes}>)

# createHashRouter
-  It uses the fragment identifier (hash) in the URL to manage and handle routes on the client side.
- changes in the URL after the(#) symbol do not trigger a full page reload, making it suitable for SPAs.

  <!-- - createHashRouter is part of the React Router library and provides routing capabilities for single-page applications (SPAs). It's commonly used for building client-side navigation within applications. Unlike traditional server-side routing, it uses the fragment identifier (hash) in the URL to manage and handle routes on the client side. This means that changes in the URL after the -->
<!-- (#) symbol do not trigger a full page reload, making it suitable for SPAs -->

# createMemoryRouter 
- It allows you to create an in-memory router for testing or other scenarios where you don't want to interact with the actual browser's URL.
 <!-- - createMemoryRouter is another routing component provided by React Router. Unlike createHashRouter or BrowserRouter createMemoryRouter is not associated with the browser's URL. Instead, it allows you to create an in-memory router for testing or other scenarios where you don't want to interact with the actual browser's URL. -->


# BrowserRouter
- BrowserRouter is a wrapper component that uses the HTML5 history API (pushState, replaceState, and the popstate event) to keep your UI in sync with the URL. 
 - BrowserRouter wraps the entire application, enabling client-side routing.

# Route
Route is a component used to define a mapping between a URL path and the component that should be rendered when that path is matched.

    <BrowserRouter>
      <Route path="/" element={<Home />} />
      <Route path="/about" element={<About />} />
    </BrowserRouter>

# Outlet
An <Outlet> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route.

Const Home=()=>{
    return(
        <Header/>
        <outlet/>
    )
}
const appRouter=createBrowserRouter(
    [
        {
            path:'/',
            element:<Home/>,
            children:[
                {
                    path:'/about',
                    element:<About/>
                }
            ]
        }
    ]
)


# Routes
- used for creating child routes

- Rendered anywhere in the app, <Routes> will match a set of child routes from the current location.
- Whenever the location changes, <Routes> looks through all its child routes to find the best match and renders that branch of the UI.
- Parent routes render their child routes by rendering an <Outlet>. 

<Routes>
  <Route path="/" element={<Dashboard />}>
    <Route
      path="messages"
      element={<DashboardMessages />}
    />
    <Route path="tasks" element={<DashboardTasks />} />
  </Route>
  <Route path="about" element={<AboutPage />} />
</Routes>

Dashboard
<>
        <ul>
          <li><Link to="messages">Messages</Link></li>
          <li><Link to="tasks">Tasks</Link></li>
        </ul>
         <Outlet />

</>

<!-- # Switch
- Switch is used to group Route components. It renders the first Route that matches the current URL. This is useful to ensure that only one Route is rendered at a time.
- Switch ensures only the first matching Route is rendered. This prevents multiple routes from rendering simultaneously. -->

# Link
A <Link> is an element that lets the user navigate to another page by clicking or tapping on it.

# useLocaion
- This hook returns the current location object. 
<!-- This can be useful if you'd like to perform some side effect whenever the current location changes. -->

# useParams (:)
- 
The useParams hook returns an object of the dynamic params from the current URL 
<!-- that were matched by the <Route path>. Child routes inherit all params from their parent routes. -->

# useSearchParams (?)
<!-- - The useSearchParams hook is used to read and modify the query string in the URL for the current location.  -->
- returns an array of two values: the current location's search params and a function that may be used to update them.

<!-- Like React's own useState hook, useSearchParams returns an array of two values: the current location's search params and a function that may be used to update them. Just as React's useState hook, setSearchParams also supports functional updates. Therefore, you may provide a function that takes a searchParams and returns an updated version. -->

<!-- # scrollRestoration
This component will emulate the browser's scroll restoration on location changes after loaders have completed to ensure the scroll position is restored to the right spot, even across domains. -->


# Code Splitting
- Code splitting is the practice of splitting your codebase into smaller chunks that can be loaded on demand rather than loading the entire application at once.
- It improves performance by reducing initial load time.
- Code splitting can be achieved using dynamic import() statements and React.lazy().

 This is particularly useful for large applications with many routes and components. 

# React.lazy
React.lazy is a function that lets you load a component asynchronously when it is needed. It helps in implementing code splitting, a technique where you split your code into smaller chunks that can be loaded on demand.

# Suspense
Suspense is a component that allows you to display a fallback UI while lazy-loaded component is being loaded. It acts as a wrapper around components that use React.lazy and can be nested to show different loading indicators for different parts of your app.

import React, { lazy, Suspense } from 'react';

const HomePage = lazy(() => import('./HomePage'));

 <BrowserRouter>
  <Suspense fallback={<div>Loading main content...</div>}>
   <Routes>
          <Route path="/" element={<HomePage />} />
          <Route
            path="/about"
            element={
              <Suspense fallback={<div>Loading about page...</div>}>
                <AboutPage />
              </Suspense>
            }
          />
  <Routes/>   
  </Suspense>     
 </BrowserRouter> 